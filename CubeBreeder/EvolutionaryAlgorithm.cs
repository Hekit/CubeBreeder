using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CubeBreeder.Selectors;
using CubeBreeder.Fitness;
using CubeBreeder.Operators;
using CubeBreeder.Replacements;

namespace CubeBreeder
{
    class EvolutionaryAlgorithm
    {
        List<Operator> operators;
        List<Selector> matingSelectors;
        List<Selector> environmentalSelectors;
        double eliteSize = 0.0;
        FitnessEvaluator fitness;
        Replacements.Replacement replacement;
        int generationNo = 0;

        /**
         * Initializes an empty evolutionary algorithm. Replacement is set to the
         * instance of SGAReplacement. All other values remain unset.
         */
        public EvolutionaryAlgorithm()
        {
            operators = new List<Operator>();
            matingSelectors = new List<Selector>();
            environmentalSelectors = new List<Selector>();
            replacement = new ChildrenOnlyReplacement();
            //replacement = new PercentageReplacement(0.9);
        }

        /**
         * Setter for the replacement.
         *
         * @param replacement The replacement which shall be used.
         */
        public void SetReplacement(Replacement replacement)
        {
            this.replacement = replacement;
        }

        /**
         * Specifies the size of the elite which shall be used.
         *
         * @param elitePercentage The percentage of population which shall be used as
         *                        elite. Should be number between 0.0 and 1.0 (inclusive).
         */
        public void SetElite(double elitePercentage)
        {
            eliteSize = elitePercentage;
        }

        /**
         * Adds a new genetic operator to the queue of genetic operators.
         *
         * @param o The operator which should be added.
         */
        public void AddOperator(Operator o)
        {
            operators.Add(o);
        }

        /**
         * Adds a new mating selector the the queue of mating selectors.
         *
         * @param s The selector which shall be added.
         */

        public void AddMatingSelector(Selector s)
        {
            matingSelectors.Add(s);
        }

        /**
         * Adds a new environmental sector to the queue of environmental selectors.
         *
         * @param s The environmental selector which shall be added.
         */
        public void AddEnvironmentalSelector(Selector s)
        {
            environmentalSelectors.Add(s);
        }

        /**
         * Sets the fitness function which is maximized by the evolutionary algoritm.
         * <p/>
         * Internally this method creates an instance of SimpleEvaluater which is used
         * the evaluate the whole population.
         *
         * @param f The fitness function which shall be used.
         */
        public void SetFitnessFunction(FitnessFunction f)
        {
            fitness = new BasicEvaluator(f);
        }

        /**
         * Sets the fitness evaluator which evaluates the whole population at once. This allows
         * to assign fitness to individuals even if the fitness of particular individual
         * depends on the fitness of other individuals in the population.
         *
         * @param fe The fitness evaluator which shall be used. Must assign fitness to all
         *           individuals in the population.
         */

        public void SetFitnessEvaluator(FitnessEvaluator fe)
        {
            fitness = fe;
        }

        /**
         * Executes one generation of the evolutionary algorithm.
         * <p/>
         * First, the mating selectors are used to create the mating pool. In this
         * step, if there are n mating selectors, each of them selects 1/n of the
         * population. The last specified selector may select more individuals to make
         * the population size constant.
         * <p/>
         * Next, the specified operators are executed in the order they were specified.
         * The population generated by an operator is used as the input for the next
         * operator in the queue.
         * <p/>
         * Then, the selection starts. First, the specified number of elite individuals
         * is added to the population of selected individuals. Then the parent and
         * offspring populations are combined using the replacement specified and
         * environmental selections are executed to select individuals from the combined
         * population. The process is similar to the one used for mating selectors.
         * <p/>
         * Finally, the individuals in the input population are replaced by the newly
         * selected individuals.
         *
         * @param pop The population on which the single generation shall be run.
         */
        public void Evolve(Population pop)
        {
            if (fitness == null)
                throw new Exception("No fitness function defined");

            generationNo++;

            fitness.Evaluate(pop, false);

            Population parents = pop;

            Population matingPool = new Population();

            if (matingSelectors.Count() > 0)
            {
                int mateSel = matingSelectors.Count;
                int toSelect = parents.GetPopulationSize() / mateSel;
                for (int i = 0; i < matingSelectors.Count; i++)
                {
                    Population sel = new Population();
                    matingSelectors[i].Select(toSelect, parents, sel);
                    matingPool.AddAll((Population)sel.Clone());
                }

                int missing = parents.GetPopulationSize() - matingPool.GetPopulationSize();
                if (missing > 0)
                {
                    Population sel = new Population();
                    matingSelectors[matingSelectors.Count - 1].Select(toSelect, parents, sel);
                    matingPool.AddAll((Population)sel.Clone());
                }
            }
            else
            {
                matingPool = (Population)parents.Clone();
                matingPool.Shuffle();
            }

            Population offspring = null;
            foreach (Operator o in operators) o.Update();
            foreach (Operator o in operators)
            {
                offspring = new Population();
                o.Operate(matingPool, offspring);
                matingPool = offspring;
            }

            fitness.Evaluate(offspring, false);

            Population selected = new Population();

            Population combined = replacement.Replace(parents, offspring);

            if (environmentalSelectors.Count < 1)
            {
                selected = (Population)combined.Clone();
                fitness.Evaluate(combined, false);
            }
            else
            {
                List<Individual> sortedOld = parents.GetSortedIndividuals();
                for (int i = 0; i < eliteSize * parents.GetPopulationSize(); i++)
                {
                    selected.Add(sortedOld[i]);
                }

                fitness.Evaluate(combined, false);

                int envSel = environmentalSelectors.Count;
                int toSelect = (parents.GetPopulationSize() - selected.GetPopulationSize()) / envSel;
                for (int i = 0; i < environmentalSelectors.Count; i++)
                {
                    Population sel = new Population();
                    environmentalSelectors[i].Select(toSelect, combined, sel);
                    selected.AddAll((Population)sel.Clone());
                }

                int missing = parents.GetPopulationSize() - selected.GetPopulationSize();
                if (missing > 0)
                {
                    Population sel = new Population();
                    environmentalSelectors[environmentalSelectors.Count - 1].Select(toSelect, combined, sel);
                    selected.AddAll((Population)sel.Clone());
                }
            }
            pop.Clear();
            pop.AddAll(selected);

            fitness.Evaluate(pop, true);
        }
    }
}